#!/usr/bin/env python3
import click

from os.path import dirname, abspath, join, isfile, relpath
from os import environ, listdir, walk
from functools import cache
from subprocess import run as srun, CalledProcessError

BASE_DIR = dirname(abspath(__file__))
SCRIPT_DIR = join(BASE_DIR, 'quickstart', 'scripts')
MOD_DIR = join(BASE_DIR, 'quickstart', 'modules')

@cache
def get_modules():
    """Get modules (flat) and scripts (recursive with relative paths)."""
    modules = listdir(MOD_DIR)
    
    # Recursively discover scripts in subdirectories
    scripts = []
    for root, dirs, files in walk(SCRIPT_DIR):
        for file in files:
            # Skip hidden files and directories
            if file.startswith('.'):
                continue
            full_path = join(root, file)
            # Get relative path from SCRIPT_DIR (e.g., "arch/paru.sh" or "brewdump")
            rel_path = relpath(full_path, SCRIPT_DIR)
            scripts.append(rel_path)
    
    return modules, scripts

@cache
def get_env():
    env = environ.copy()
    env['BASE_DIR'] = BASE_DIR
    return env

def cli_run(cmd: list[str], capture_output=False):
    try:
        res = srun(cmd, capture_output=capture_output, text=True, check=True, env=get_env())
        return res
    except CalledProcessError as e:
        click.echo(e.stderr)
        exit(1)
    except Exception as e:
        click.echo(e)
        exit(1)

def run_all_modules():
    modules, _ = get_modules()
    for mod in modules:
        p = join(MOD_DIR, mod)
        cli_run(['bash' , p])


@click.group()
def dev():
    pass

@dev.command(help='runs install.sh which runs install script for your platform and installs all modules')
def install():
    cmd = f"bash {join(BASE_DIR,'quickstart', 'install.sh')}".split()
    res = cli_run(cmd)
    click.echo(f"{res.stdout}")
    run_all_modules()


@dev.command(help='run specific modules or scripts by name')
@click.argument('modules', nargs=-1) # -1 means "all remaining arguments"
@click.pass_context
def run(ctx, modules: tuple[str]):
    if len(modules) < 1:
        ctx.invoke(list)
        raise click.BadArgumentUsage("At least one module or script must be passed in see <dev list>")
    # Validate
    existing_modules, scripts = get_modules()
    valid_s, valid_m, invalid = set(), set(), set()
    
    # Create lookup dict for modules - support both with and without extension
    module_lookup = {}
    for mod in existing_modules:
        # Full filename (e.g., "fish_env.sh")
        module_lookup[mod] = mod
        # Without extension (e.g., "fish_env")
        module_lookup[mod.rsplit('.', 1)[0]] = mod
    
    # Create lookup dict for scripts - support both full path and basename
    script_lookup = {}
    for s in scripts:
        # Full path (e.g., "arch/paru.sh")
        script_lookup[s] = s
        # Without extension (e.g., "arch/paru")
        script_lookup[s.rsplit('.', 1)[0]] = s
        # Just basename without extension (e.g., "paru")
        basename = s.split('/')[-1].rsplit('.', 1)[0]
        # Only add basename if it's unique (avoid conflicts)
        if basename not in script_lookup:
            script_lookup[basename] = s
    
    for m in modules:
        if m in module_lookup:
            valid_m.add(module_lookup[m])
            continue
        elif m in script_lookup:
            # Use the full relative path from lookup
            valid_s.add(script_lookup[m])
            continue
        invalid.add(m)
        click.secho(f"{m} is invalid",fg='red')
    if len(invalid):
        click.secho("See list of available modules and scripts", fg='red')
        ctx.invoke(list)
    
    # Run scripts and modules
    for s in valid_s:
        script = join(SCRIPT_DIR, s)
        cli_run(['bash', script])
    
    for m in valid_m:
        mod = join(MOD_DIR, m)
        cli_run(['bash', mod])
    
    
@dev.command(help='lists available modules and scripts')
def list():
    modules, scripts = get_modules()
    click.secho("Modules:", fg='green')
    for mod in modules:
        click.echo(f"  {mod.split('.')[0]}")
    
    click.secho("\nScripts:", fg='green')
    # Group scripts by directory for better organization
    script_dict = {}
    for s in scripts:
        if '/' in s:
            category = s.split('/')[0]
            name = s.split('/')[-1].split('.')[0]
            if category not in script_dict:
                script_dict[category] = []
            script_dict[category].append((s, name))
        else:
            # Top-level scripts
            if 'root' not in script_dict:
                script_dict['root'] = []
            script_dict['root'].append((s, s.split('.')[0]))
    
    # Display organized by category
    for category in sorted(script_dict.keys()):
        if category == 'root':
            for full_path, name in script_dict[category]:
                click.echo(f"  {name}")
        else:
            click.secho(f"  [{category}]", fg='cyan')
            for full_path, name in script_dict[category]:
                click.echo(f"    {name} ({full_path})")
    click.echo()



def is_valid_filename(name: str) -> bool:
    """
    Validate filename for safety and filesystem compatibility.
    
    Args:
        name: Proposed filename
        
    Returns:
        True if filename is valid, False otherwise
    """
    # Check for empty or whitespace-only
    if not name or name != name.strip():
        return False
    
    # Check length (filesystem limit)
    if len(name) > 255:
        return False
    
    # Check for path separators, parent directory references, and null bytes
    invalid_chars = ['/', '\\', '\0']
    if any(char in name for char in invalid_chars):
        return False
    
    # Check for parent directory traversal
    if '..' in name:
        return False
    
    return True


def chooseBrewfile(path):
    """
    Lists out brewfiles at path and returns selected path.
    Users can select by number (1, 2, 3...), by name, or enter a new filename to create.
    
    Returns:
        str: Full path to selected or new Brewfile
        None: If user cancels operation
    """
    try:
        files = [f for f in listdir(path) if isfile(join(path, f))]
    except FileNotFoundError:
        click.secho(f"Directory {path} not found", fg='red')
        return None
    
    # Handle empty directory - allow creation
    if not files:
        click.secho(f"No files found in {path}", fg='yellow')
        click.echo("You can create a new Brewfile by entering a filename.")
    else:
        # Display enumerated choices
        click.echo("Available Brewfiles:")
        for idx, file in enumerate(files, start=1):
            click.echo(f"  {idx}. {file}")
    
    # Prompt for selection
    while True:
        choice = click.prompt("\nSelect a Brewfile (number, name, or enter new filename)", type=str).strip()
        
        # Empty input check
        if not choice:
            click.secho("Filename cannot be empty", fg='red')
            continue
        
        # Try to parse as number
        try:
            num = int(choice)
            if 1 <= num <= len(files):
                return join(path, files[num - 1])
            else:
                click.secho(f"Number must be between 1 and {len(files)}", fg='red')
                continue
        except ValueError:
            pass  # Not a number, continue to filename checks
        
        # Check if exact filename match
        if choice in files:
            return join(path, choice)
        
        # Validate as potential new filename
        if not is_valid_filename(choice):
            click.secho(
                f"'{choice}' contains invalid characters. "
                "Avoid path separators (/, \\), parent directory references (..), and control characters.",
                fg='red'
            )
            continue
        
        # Confirm creation of new file
        confirm_msg = f"Create new Brewfile '{choice}' at '{path}/'?"
        if click.confirm(confirm_msg, default=False):
            click.secho(f"Will create new Brewfile: {choice}", fg='green')
            return join(path, choice)
        else:
            # User declined creation
            if click.confirm("Try again?", default=True):
                continue  # Retry selection
            else:
                click.secho("Operation cancelled", fg='yellow')
                return None


@dev.command(help='Uses Brew to dump Brewfile')
@click.option('--file', '-f', help='Brewfile name', default='Brewfile')
@click.option('--force/--no-force', is_flag=True, help='Overwrite existing file', default=True)
@click.option('--path', '-p', help='Override target path', default=None)
def brewdump(file: str, force: bool, path):
    """Runs brew bundle dump to export installed packages."""
    path = path if path is not None else join(BASE_DIR, 'quickstart', 'apps')
    target = chooseBrewfile(path) if force else join(path, file)
    
    cmd = ['brew', 'bundle', 'dump', '--file', target]
    if force:
        cmd.append('--force')
    
    click.echo(f"Dumping Brewfile to {target}...")
    cli_run(cmd)
    click.secho(f"âœ“ Brewfile dumped to {target}", fg='green')


if __name__ == "__main__":
    dev()
