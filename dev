#!/usr/bin/env python3
import click

from os.path import join

from helpers import (
    BASE_DIR,
    SCRIPT_DIR,
    MOD_DIR,
    get_modules,
    get_scripts,
    cli_run,
    run_all_modules,
    is_valid_filename,
    chooseBrewfile
)


@click.group()
@click.option('--dry-run', is_flag=True, help='Show what would be executed without running commands')
@click.pass_context
def dev(ctx, dry_run):
    """Development environment setup CLI."""
    ctx.ensure_object(dict)
    ctx.obj['dry_run'] = dry_run

@dev.command()
@click.pass_context
def help(ctx):
    """Display help information for the dev CLI."""
    click.echo(ctx.parent.get_help())

@dev.command(help='runs install.sh which runs install script for your platform and installs all modules')
@click.pass_context
def install(ctx):
    dry_run = ctx.obj.get('dry_run', False)
    cmd = f"bash {join(BASE_DIR,'quickstart', 'install.sh')}".split()
    res = cli_run(cmd, dry_run=dry_run)
    click.echo(f"{res.stdout}")
    run_all_modules(dry_run=dry_run)


@dev.command(help='run specific modules or scripts by name')
@click.argument('modules', nargs=-1) # -1 means "all remaining arguments"
@click.pass_context
def run(ctx, modules: tuple[str]):
    dry_run = ctx.obj.get('dry_run', False)
    if len(modules) < 1:
        ctx.invoke(list)
        raise click.BadArgumentUsage("At least one module or script must be passed in see <dev list>")
    # Validate
    existing_modules = get_modules()
    scripts = get_scripts()
    valid_s, valid_m, invalid = set(), set(), set()
    
    # Create lookup dict for modules - support both with and without extension
    module_lookup = {}
    for mod in existing_modules:
        # Full filename (e.g., "fish_env.sh")
        module_lookup[mod] = mod
        # Without extension (e.g., "fish_env")
        module_lookup[mod.rsplit('.', 1)[0]] = mod
    
    # Create lookup dict for scripts - support both full path and basename
    script_lookup = {}
    for s in scripts:
        # Full path (e.g., "arch/paru.sh")
        script_lookup[s] = s
        # Without extension (e.g., "arch/paru")
        script_lookup[s.rsplit('.', 1)[0]] = s
        # Just basename without extension (e.g., "paru")
        basename = s.split('/')[-1].rsplit('.', 1)[0]
        # Only add basename if it's unique (avoid conflicts)
        if basename not in script_lookup:
            script_lookup[basename] = s
    
    for m in modules:
        if m in module_lookup:
            valid_m.add(module_lookup[m])
            continue
        elif m in script_lookup:
            # Use the full relative path from lookup
            valid_s.add(script_lookup[m])
            continue
        invalid.add(m)
        click.secho(f"{m} is invalid",fg='red')
    if len(invalid):
        click.secho("See list of available modules and scripts", fg='red')
        ctx.invoke(list)
    
    # Run scripts and modules
    for s in valid_s:
        script = join(SCRIPT_DIR, s)
        cli_run(['bash', script], dry_run=dry_run)
    
    for m in valid_m:
        mod = join(MOD_DIR, m)
        cli_run(['bash', mod], dry_run=dry_run)
    
    
@dev.command(help='lists available modules and scripts')
def list():
    modules = get_modules()
    scripts = get_scripts()
    click.secho("Modules:", fg='green')
    for mod in modules:
        click.echo(f"  {mod.split('.')[0]}")
    
    click.secho("\nScripts:", fg='green')
    # Group scripts by directory for better organization
    script_dict = {}
    for s in scripts:
        if '/' in s:
            category = s.split('/')[0]
            name = s.split('/')[-1].split('.')[0]
            if category not in script_dict:
                script_dict[category] = []
            script_dict[category].append((s, name))
        else:
            # Top-level scripts
            if 'root' not in script_dict:
                script_dict['root'] = []
            script_dict['root'].append((s, s.split('.')[0]))
    
    # Display organized by category
    for category in sorted(script_dict.keys()):
        if category == 'root':
            for full_path, name in script_dict[category]:
                click.echo(f"  {name}")
        else:
            click.secho(f"  [{category}]", fg='cyan')
            for full_path, name in script_dict[category]:
                click.echo(f"    {name} ({full_path})")
    click.echo()


BREW_MODES: list  = ['dump', 'install', 'cleanup']
@dev.command(name='brew_bundle', help='Interactively use Brew bundle to manage packages')
@click.option('--mode', '-m', type=click.Choice(BREW_MODES), default='dump', help='Take different brew bundle actions')
@click.option('--file', '-f', help='Brewfile name')
@click.option('--force/--no-force', help='Overwrite existing file', default=True)
@click.option('--path', '-p', help='Override target path', default=None)
@click.pass_context
def brew(ctx, mode: str, file: str, force: bool, path):
    """Runs brew bundle dump to export installed packages."""
    dry_run = ctx.obj.get('dry_run', False)
    
    default_path = join(BASE_DIR, 'quickstart', 'apps')
    path = path if path is not None else default_path
    target = chooseBrewfile(path) if file is  None else join(path, file)
    
    cmd = ['brew', 'bundle',  mode,  '--file', target]
    if force:
        cmd.append('--force')
    
    click.echo(f"Dumping Brewfile to {target}...")
    cli_run(cmd, dry_run=dry_run)
    click.secho(f"âœ“ Brewfile dumped to {target}", fg='green')


if __name__ == "__main__":
    dev()
