#!/usr/bin/env python3
import click

from os.path import dirname, abspath, join, isfile, relpath
from os import environ, listdir, walk
from functools import cache
from subprocess import run as srun, CalledProcessError

BASE_DIR = dirname(abspath(__file__))
SCRIPT_DIR = join(BASE_DIR, 'quickstart', 'scripts')
MOD_DIR = join(BASE_DIR, 'quickstart', 'modules')

@cache
def get_modules():
    """Get modules (flat) and scripts (recursive with relative paths)."""
    modules = listdir(MOD_DIR)
    
    # Recursively discover scripts in subdirectories
    scripts = []
    for root, dirs, files in walk(SCRIPT_DIR):
        for file in files:
            # Skip hidden files and directories
            if file.startswith('.'):
                continue
            full_path = join(root, file)
            # Get relative path from SCRIPT_DIR (e.g., "arch/paru.sh" or "brewdump")
            rel_path = relpath(full_path, SCRIPT_DIR)
            scripts.append(rel_path)
    
    return modules, scripts

@cache
def get_env():
    env = environ.copy()
    env['BASE_DIR'] = BASE_DIR
    return env

def cli_run(cmd: list[str], capture_output=False):
    try:
        res = srun(cmd, capture_output=capture_output, text=True, check=True, env=get_env())
        return res
    except CalledProcessError as e:
        click.echo(e.stderr)
        exit(1)
    except Exception as e:
        click.echo(e)
        exit(1)

def run_all_modules():
    modules, _ = get_modules()
    for mod in modules:
        p = join(MOD_DIR, mod)
        cli_run(['bash' , p])


@click.group()
def dev():
    pass

@dev.command(help='runs install.sh which runs install script for your platform and installs all modules')
def install():
    cmd = f"bash {join(BASE_DIR,'quickstart', 'install.sh')}".split()
    res = cli_run(cmd)
    click.echo(f"{res.stdout}")
    run_all_modules()


@dev.command(help='run specific modules or scripts by name')
@click.argument('modules', nargs=-1) # -1 means "all remaining arguments"
@click.pass_context
def run(ctx, modules: tuple[str]):
    if len(modules) < 1:
        ctx.invoke(list)
        raise click.BadArgumentUsage("At least one module or script must be passed in see <dev list>")
    # Validate
    existing_modules, scripts = get_modules()
    valid_s, valid_m = set(), set()
    invalid = set()
    
    # Create lookup dict for modules - support both with and without extension
    module_lookup = {}
    for mod in existing_modules:
        # Full filename (e.g., "fish_env.sh")
        module_lookup[mod] = mod
        # Without extension (e.g., "fish_env")
        module_lookup[mod.rsplit('.', 1)[0]] = mod
    
    # Create lookup dict for scripts - support both full path and basename
    script_lookup = {}
    for s in scripts:
        # Full path (e.g., "arch/paru.sh")
        script_lookup[s] = s
        # Without extension (e.g., "arch/paru")
        script_lookup[s.rsplit('.', 1)[0]] = s
        # Just basename without extension (e.g., "paru")
        basename = s.split('/')[-1].rsplit('.', 1)[0]
        # Only add basename if it's unique (avoid conflicts)
        if basename not in script_lookup:
            script_lookup[basename] = s
    
    for m in modules:
        if m in module_lookup:
            valid_m.add(module_lookup[m])
            continue
        elif m in script_lookup:
            # Use the full relative path from lookup
            valid_s.add(script_lookup[m])
            continue
        invalid.add(m)
        click.secho(f"{m} is invalid",fg='red')
    if len(invalid):
        click.secho("See list of available modules and scripts", fg='red')
        ctx.invoke(list)
    
    # Run scripts and modules
    for s in valid_s:
        script = join(SCRIPT_DIR, s)
        cli_run(['bash', script])
    
    for m in valid_m:
        mod = join(MOD_DIR, m)
        cli_run(['bash', mod])
    
    
@dev.command(help='lists available modules and scripts')
def list():
    modules, scripts = get_modules()
    click.secho("Modules:", fg='green')
    for mod in modules:
        click.echo(f"  {mod.split('.')[0]}")
    
    click.secho("\nScripts:", fg='green')
    # Group scripts by directory for better organization
    script_dict = {}
    for s in scripts:
        if '/' in s:
            category = s.split('/')[0]
            name = s.split('/')[-1].split('.')[0]
            if category not in script_dict:
                script_dict[category] = []
            script_dict[category].append((s, name))
        else:
            # Top-level scripts
            if 'root' not in script_dict:
                script_dict['root'] = []
            script_dict['root'].append((s, s.split('.')[0]))
    
    # Display organized by category
    for category in sorted(script_dict.keys()):
        if category == 'root':
            for full_path, name in script_dict[category]:
                click.echo(f"  {name}")
        else:
            click.secho(f"  [{category}]", fg='cyan')
            for full_path, name in script_dict[category]:
                click.echo(f"    {name} ({full_path})")
    click.echo()

if __name__ == "__main__":
    dev()
